global:
  # rpc urls
  # 示例：配置多个端点用于冗余 / 负载均衡，按顺序轮询。
  # rpc_urls:
  #   - "https://rpc.shyft.to?api_key=FgU1AVt-7pIiUk2j"
  #   - "https://mainnet.helius-rpc.com/?api-key=767f42d9-06c2-46f8-8031-9869035d6ce4"
  #   - "https://mainnet.solana.validationcloud.io/v1/4YlOowpz6fTe6Jl31oWxYGSusOS12UzTxXkpdoC1I5A"
  #   - "https://mainnet.helius-rpc.com/?api-key=39602420-7609-49be-905e-92421ddcb342"
  # pump
  #   - "https://mainnet.helius-rpc.com/?api-key=767f42d9-06c2-46f8-8031-9869035d6ce4"
  #   - "https://pump-fe.helius-rpc.com/?api-key=1b8db865-a5a1-4535-9aec-01061440523b"

  rpc_urls:
    - "https://mainnet.helius-rpc.com/?api-key=767f42d9-06c2-46f8-8031-9869035d6ce4"
#    - "https://pump-fe.helius-rpc.com/?api-key=1b8db865-a5a1-4535-9aec-01061440523b"
  # yellowstone grpc url
  proxy: ""
  yellowstone_grpc_url: ""
  # yellowstone grpc token
  yellowstone_grpc_token: ""

  wallet:
    # 套利钱包的私钥 loss
    private_key: ""
    # copy
    # private_key: "5nZhEDFQXG9GDURkRi7RmtzeZ7WywjW7MMmu7BdvHSG7WpmvxxfqomFkbHhEthMajrv31zRKxei2GdNawnnx2RF6"
    # 自动 unwrap WSOL 到 SOL
    auto_unwrap:
      # 开启后当钱包 SOL 余额低于阈值时，自动把 WSOL 解包为 SOL
      enable: false
      # 每次自动解包的金额
      unwrap_amount_lamports: 1000000000
      # 钱包允许的最小 SOL 余额阈值（单位：lamports）
      min_sol_balance_lamports: 1000000000
      # 执行解包交易时使用的 CU price（单位：微 lamports）
      compute_unit_price_micro_lamports: 0

  instruction:
    # 指令备注
    memo: ""

  # 日志级别
  logging:
    level: "info"
    json: false
    # 日志输出的时区偏移（单位：小时）。示例：8 代表 UTC+8。
    timezone_offset_hours: 8

engine:
  # 可选值：jupiter / dflow / ultra / multi-legs /none
  backend: "dflow"
  # backend: "ultra"
  # backend: "multi-legs"
  # backend: "dflow"
  jupiter:
    enable: false
    api_proxy: ""
    args_included_dexes: [
        # TesseraV
        "TessVdML9pBGgG9yGks7o4HewRaXVAMuoVj4x83GLQH",
        # SolFiV2
        "SV2EYYJyRz2YhfXwXnhNAevDEui5Q6yrfyo13WtupPF",
        # HumidiFi
        "9H6tua7jkLhdm3w8BvgpTn5LZNU7g4ZynDmCiNN3q6Rp",
        # Aquifer
        "AQU1FRd7papthgdrwPTTq5JacJh8YtwEXaBfKU3bTz45",
      ]
    quote_config:
      # 设置为 true 时，机器人将仅寻找两跳（A -> B -> A）交易。设置为 true 将缩短跳转报价时间，加快落地速度。设置为 false 将获得更多机会，但需要更多报价时间。
      only_direct_routes: false
      # 仅当 use_direct_route_only 为 false 时，此设置才会生效。
      # 将中间代币限制为具有稳定流动性的顶级代币集合。这将有助于降低兑换时潜在的高滑点错误率，并将对定价的影响降至最低。
      # 当您将 use_direct_route_only 设置为 false 时，这可以帮助加快 jupiter 的报价时间。不过，正如它所说，它也会限制在您的路线中使用的额外 mint。
      restrict_intermediate_tokens: true
      # QuoteDispatcher 并发配置："auto" 按 trade size + IP 容量自动取最小值，也可填写正整数强制并发
      parallelism: "auto"
      # 报价批次发送间隔（毫秒），用于在批次之间加额外退避；0 表示禁用
      batch_interval_ms: 0
    swap_config:
      # 跳过用户账户相关 RPC 调用，以减少重复拉取。
      # 设置为 false 时，不会有 setupInstructions 等创建 ATA 的指令
      # 设置为 true 时，会有 setupInstructions 等创建 ATA 的指令
      skip_user_accounts_rpc_calls: false
      # 启用后，它将进行交换模拟以获取使用的计算单元并将其设置在 ComputeBudget 的计算单元限制中
      # 这会导致一个额外的 RPC 调用来模拟这个交易
      # 我们建议启用此功能以正确估计计算单元并减少所需的优先费用或有更高的机会被纳入区块
      dynamic_compute_unit_limit: true
      wrap_and_unwrap_sol: false
  ultra:
    enable: true
    # 腿方向：可选 buy / sell，用于套利腿角色匹配
    leg: "sell"
    api_quote_base: "https://ultra-api.jup.ag"
    api_swap_base: "https://ultra-api.jup.ag"
    api_proxy: ""
    quote_config:
      use_wsol: true
      taker: "k1bWgJv1fdVMCqgDM2jkEfhEzKW7XgGpj8vGGKjgSnJ"
      # taker: "P1ayvj9UdRxiVWa6rxXbqmosF1tZf62VZSJnrUnvhak"
      exclude_routers: []
      priority_fee_lamports: 10
      # Ultra 报价并发，同 jupiter.quote_config.parallelism 语义
      parallelism: "auto"
      # Ultra 报价批次间隔（毫秒），0 表示不额外延迟
      batch_interval_ms: 0
    swap_config:
      cu_limit_multiplier: 0.92
  dflow:
    enable: true
    # 腿方向：可选 buy / sell，用于套利腿角色匹配
    leg: "sell"

    # api_quote_base: "https://aggregator-api-proxy.dflow.workers.dev"
    api_quote_base: "https://quote-api.dflow.net"
    api_swap_base: "https://quote-api.dflow.net"
    api_proxy: ""
    quote_config:
      use_auto_slippage: false
      only_direct_routes: false
      max_route_length: 3
      # DFlow 报价并发，同 jupiter.quote_config.parallelism 语义
      parallelism: "auto"
      # DFlow 报价批次间隔（毫秒），0 表示不额外延迟
      batch_interval_ms: 0
    swap_config:
      dynamic_compute_unit_limit: true
      wrap_and_unwrap_sol: false
      cu_limit_multiplier: 0.94
  titan:
    enable: true
    # 腿方向：Titan 仅支持 buy 腿
    leg: "buy"
    # Titan 推流首条报价超时时间（毫秒），超过后视为异常并重新调度
    first_quote_timeout_ms: 2000
    # 开启 loopback 后仅订阅 base→base 的单条 Titan 流，根据 out>in 判断套利
    ws_url: "wss://api.titan.exchange/api/v1/ws"
    # 可选：通过 WebSocket 代理抓包/调试 Titan 数据
    # ws_proxy: "ws://192.168.124.4:9999"
    ws_proxy: ""
    # Titan 目前要求使用内置账户发起报价，如需自定义可在拿到白名单后修改
    default_pubkey: 
    jwt: "eyJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE3NjE2NjYyMDksImV4cCI6MTc2MTY2NzEwOSwic3ViIjoiZ2VuZXJpY19mcm9udGVuZF91c2VyIiwiYXVkIjoiYXBpLnRpdGFuLmFnIiwiaXNzIjoiaHR0cHM6Ly9qd3QtYXV0aC13b3JrZXItcHJvZC5kZWxpY2F0ZS1zaWxlbmNlLTE2Nzcud29ya2Vycy5kZXYvIiwiaHR0cHM6Ly9hcGkudGl0YW4uYWcvdXBrX2I1OCI6IlRpdGFuMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEifQ.FQ0GjAUfJRM52Ea2NfIYeSENozov0gOfHbVX7AsFRfY"
    # Titan , Okx , Metis , Pyth
    swap_config:
      # dexes: 
      # exclude_dexes:
      only_direct_routes: false
      providers:
        - "Titan"
        # - "Metis"
    tx_config:
      user_public_key: "Titan11111111111111111111111111111111111111"
      # user_public_key: "goopNoaJhhrzxi6oq2j4chcyHKGucAeVZSk4QBA7Gu1"
      create_output_token_account: false
      use_wsol: true
    # 服务端推送报价更新的间隔，单位毫秒。
    interval_ms: 800
    # 每次更新最多返回的报价数量。
    num_quotes: 2
  kamino:
    enable: true
    # 腿方向：可选 buy / sell，用于套利腿角色匹配
    leg: "buy"
    api_quote_base: "https://api.kamino.finance"
    api_swap_base: "https://api.kamino.finance"
    api_proxy: ""
    quote_config:
      max_slippage_bps: 0
      executor: ""
      referrer_pda: ""
      include_setup_ixs: true
      wrap_and_unwrap_sol: false
      routes:
        - "dflow"
        - "jupiter"
        - "jupiterSelfHosted"
        - "jupiterEuropa"
        - "per"
        - "fluxbeam"
        - "raydium"
        - "hashflow"
        - "okx"
        - "clover"
        - "zeroEx"
        - "spur"
        - "lifi"
      
# 机器人会尝试找到盈利路线，具体方法是：获取给定交易规模的 base_mint 到 intermediate_mints 的报价，
# 然后再获取 intermediate_mints 到 base_mint 的另一个报价，
# 并将它们组合起来，形成一条潜在的盈利路线。基本上就是一条从 A -> B -> A 的路线。
# 当 use_direct_route_only 设置为 true 时，机器人将仅返回类似上述 A -> B -> A 形式的路线。
# 为了获得更多潜在机会，您可以将其设置为 false，这样可以返回类似 A -> B -> C -> A 形式的路线。
# 将其设置为 false 的缺点是会减慢获取报价的时间，最终导致交易发送速度变慢。
intermedium:
  load_mints_from_files: []
  load_mints_from_url: ""
  max_tokens_limit: 20
  mints:
    - "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
    - "So11111111111111111111111111111111111111112"
    # Bonk
    # - "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263"
    # # MET
    # - "METvsvVRapdj9cFLzq4Tr43xK4tAjQfwX76z3n6mWQL"
    # # JLP
    # - "27G8MtK7VtTcCHkpASjSDdkWWYfoqT6ggEuKidVJidD4"
    # # cbBTC
    # # PUMP
    # - "pumpCmXqMfrsAkQ5r49WcJnRayYRqmXz6ae8H7H9Dfn"
    # # JitoSOL
    # - "J1toso1uCk3RLmjorhTtrVwY9HJ7X8V9yYac6Y7kGCPn"
    # # Saros
    # - "SarosY6Vscao718M4A778z4CGtvcwcGef5M9MEH1LGL"
  disable_mints: []

bot:
  # 是否测试模式
  dry_run: false
  cpu_affinity:
    # 开启后，bot 会将 Tokio runtime 线程绑定到指定 CPU 核，避免与验证节点争抢
    enable: false
    # 按顺序列出可用的物理/超线程 ID，例如 [3,4,5,6]；留空表示使用全部可用核心
    worker_cores: []
    # 可选：限制 Tokio 阻塞线程池的最大线程数；置空表示使用默认值
    max_blocking_threads: null
    # 严格模式：当核心列表无效时直接报错退出，而不是回退到默认调度
    strict: false
  network:
    # 是否启用多 IP 资源池；false 时退化为单 IP 但仍会走统一调度
    enable_multiple_ip: true
    # 手动指定可用的本地 IP 白名单，留空则使用自动发现
    manual_ips: []
    # 排除的本地 IP 黑名单，优先级高于白名单
    blacklist_ips: []
    # 调试时是否允许使用回环地址（127.0.0.1 等）
    allow_loopback: false
    # 单个 IP 同时允许的并发请求数；null 表示仅受退避逻辑约束
    per_ip_inflight_limit: null
    cooldown_ms:
      # 命中 429 / 限流时的初始冷却时间（毫秒）
      rate_limited_start: 500
      # 连接超时 / 网络异常时的初始冷却时间（毫秒）
      timeout_start: 250
  # 是否启用 prometheus
  prometheus:
    enable: false
    listen: "127.0.0.1:9898"
  # 设置为 true 时，不会在本地启动 Jupiter API。当你想在同一台机器上运行多个机器人时，这很有用。
  disable_local_binary: false
  # 是否禁止启动机器人
  disable_running: false
  # 超时时间：报价 / 指令 / 落地（单位：毫秒）
  quote_ms: 2000
  swap_ms: 10000
  landing_ms: 5000
  # 自动重启 jupiter binary 的时间间隔，单位为分钟，0表示不重启
  auto_restart_minutes: 30
  # 是否通过 geyser 获取 block hash, 否则通过 rpc 获取
  get_block_hash_by_grpc: true
  # 是否允许模拟
  enable_simulation: false
  # 是否在本地终端打印 Jupiter 二进制输出（默认开启，可保持彩色日志）。
  show_jupiter_logs: true

flashloan:
  marginfi:
    # 是否启用 flash 贷款
    enable: true
    # 优先使用钱包余额；若交易规模在余额内，则跳过闪电贷
    prefer_wallet_balance: true
    # 闪电贷指令额外的 compute unit 开销
    compute_unit_overhead: 110000
    marginfi_account: "3TmqCbKgsBEgnPMmi1YvdHvUq76v8qbx6JFH2YYyettJ"

# lander 相关配置已移至独立的 lander.yaml

# 盲发策略
blind_strategy:
  enable: true
  memo: ""
  # 只允许交易这些 dex
  enable_dexs: [
      # "HumidiFi",
      # "SolFi",
      # "SolFi V2",
      # "Tessera V",
      # "ZeroFi",
      # "Whirlpools",
      # "Obric V2",
      # "Aquifer",
      # "Lifinity V2",
      # "DFlow JIT Router"
    ]
  exclude_dexes: [
      # 通过 exclude_dexes 会在 DFlow /quote 请求中拼接为 excludeDexes 参数
      # "DFlow JIT Router",
    ]
  enable_landers: [
      "jito",
    ]
  # 自动根据 IP 容量扩展各 lane 的交易规模数量，避免手动维护庞大的 trade size 列表。
  # - 关闭时仅按照每个 lane 的 `count` 生成固定数量的规模。
  # - 开启时会统计本地可用 IP 数与 `per_ip_inflight_limit`，如果 trade size 总量不足以填满，就按 lane `weight` 分配额外档位。
  # - `max_multiplier` 用于限制单个 lane 的最大扩容倍数（最终档位不会超过 `count * max_multiplier`）。
  auto_scale_to_ip:
    enable: true
    max_multiplier: 3.0
  base_mints:
    - mint: "So11111111111111111111111111111111111111112"
      # 每个 lane 描述一个交易规模区间与生成策略：
      # - min/max：规模范围（单位 lamports）
      # - count：初始生成多少个规模；结合 auto_scale 时也作为扩容基数
      # - strategy：linear / exponential / random
      # - weight：auto_scale 启用时的扩容权重（可选，默认 1.0）
      lanes:
        - min: 1_500_000_000   # 1.5 SOL
          max: 10_000_000_000  # 10 SOL
          count: 16
          strategy: linear
          weight: 1.0
      # 最小利润
      min_quote_profit: 34000
      # 交易延时
      # 单位为毫秒。默认值表示机器人将等待 1000 毫秒，然后针对相同代币交易规模的对再次尝试。减少此值将增加立即捕捉价格变化的机会，但会增加读取 RPC 负载。
      process_delay: 1200
      # 冷却时间
      # 如果找到一个机会并且发送了 tx，则至少等待这个时间（ms）才能发送另一个。
      sending_cooldown: 1000
      # 路由类型
      # 2hop ：这意味着只有像 A -> B -> A 这样的路由才会被考虑。如果您还将 use_direct_route_only 设置为 false，则 A->B 和 B->A 之间可能存在其他铸币厂。
      # 3hop ：这意味着只会考虑像 A -> B -> C -> A 这样的路线。您需要设置除了所有中间铸币厂之外，还希望在中间包含哪些额外的铸币厂。
      # 最常见的用例是使用 SOL 和 USDC 为路线报价，例如 SOL -> USDC -> X -> SOL。3hop 会产生与将 use_direct_route_only 设置为 false 类似的结果，但报价时间要快得多
      # 使用 3hop 时还需要定义 three_hop_mints
      route_types:
        - "2hop"
        - "3hop"
      # 三跳交易中，中间的铸币厂
      three_hop_mints:
        - "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
    - mint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
      lanes:
        - min: 60_000_000
          max: 600_000_000
          count: 12
          strategy: linear
          weight: 1.0
        - min: 600_000_000
          max: 3_600_000_000
          count: 18
          strategy: exponential
          weight: 0.8
      # 最小利润
      min_quote_profit: 22000
      # 交易延时
      # 单位为毫秒。默认值表示机器人将等待 1000 毫秒，然后针对相同代币交易规模的对再次尝试。减少此值将增加立即捕捉价格变化的机会，但会增加读取 RPC 负载。
      process_delay: 1200
      # 冷却时间
      # 如果找到一个机会并且发送了 tx，则至少等待这个时间（ms）才能发送另一个。
      sending_cooldown: 1000
      # 路由类型
      # 2hop ：这意味着只有像 A -> B -> A 这样的路由才会被考虑。如果您还将 use_direct_route_only 设置为 false，则 A->B 和 B->A 之间可能存在其他铸币厂。
      # 3hop ：这意味着只会考虑像 A -> B -> C -> A 这样的路线。您需要设置除了所有中间铸币厂之外，还希望在中间包含哪些额外的铸币厂。
      # 最常见的用例是使用 SOL 和 USDC 为路线报价，例如 SOL -> USDC -> X -> SOL。3hop 会产生与将 use_direct_route_only 设置为 false 类似的结果，但报价时间要快得多
      # 使用 3hop 时还需要定义 three_hop_mints
      route_types:
        - "2hop"
        - "3hop"
      # 三跳交易中，中间的铸币厂
      three_hop_mints:
        - "So11111111111111111111111111111111111111112"


# 纯盲发策略（与 blind_strategy 并行配置，互不影响）
pure_blind_strategy:
  # 纯盲发主开关；true 时忽略 blind_strategy 的报价链路
  enable: false            
  # 纯盲发策略允许使用的落地器（顺序影响优先级）
  enable_landers: []

  market_cache:
    # Jupiter markets.json 快照
    path: "./cache/pure_markets.json"              
    # 自动拉取更新时用
    download_url: "https://cache.jup.ag/markets?v=4" 
    proxy: "http://192.168.124.4:2080"
    # 可选：定时刷新缓存（0=禁用）
    auto_refresh_minutes: 120
    # 当设置为 true 时，dexes 下有实现的，盲发支持的，才会保留，否则会过滤掉
    exclude_other_dex_program_ids: true
    exclude_dex_program_ids: [
      "CAMMCz6GM1DNKyvHRAAmcX6vLLANBYdmsKtfgfcJQ68X",
      "LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo",
      "whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc"
    ]
    # 可选：按 TVL/深度阈值过滤
    min_liquidity_usd: 50000                       

  # 描述闭环入口资产以及想要探索的中间资产集合
  assets:
    base_mints:
      - mint: "So11111111111111111111111111111111111111112"
        trade_sizes: [5_000_000_000, 10_000_000_000]   # lamports
        # 限制发送的频率，单位为毫秒
        process_delay: 1000
        # 路由类型，是 3 跳还是 2 跳
        route_type: "2hop"
      - mint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
        trade_sizes: [1_000_000_000, 2_000_000_000]
        # 限制发送的频率，单位为毫秒
        process_delay: 1000
        # 路由类型，是 3 跳还是 2 跳
        route_type: "3hop"
    intermediates:
      - "So11111111111111111111111111111111111111112"
      - "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
    blacklist_mints: []        # 明确禁用的中间资产
  overrides:                   # 手工指定的闭环（自动生成失败时可兜底）
    # - name: "humidifi_whirlpool_zerofi_cycle"
    #   legs:
    #     - market: "DB3sUCP2H4icbeKmK6yb6nUxU5ogbcRHtGuq7W2RoRwW" # HumidiFi
    #     - market: "HktfL7iwGKT5QHjywQkcDnZXScoh811k7akrMZJkCcEF" # Whirlpools
    #     - market: "BqkNuLTbUZLifWuUtfF5CkyRegTQhYYgUnNeUaxoWC8S" # ZeroFi
    #   lookup_tables:
    #     - "3RRynG7FN6FkVaAyZPHwZSAGYUWzxb1EmtM5CfrShhsw"
    #     - "AW3raiF9cvqu8d5JgCXmCi8kh16Aba86gWVi9pbNYNNc"
    #   trade_sizes: [7_500_000_000]

  monitoring:
    enable_metrics: true
    route_labels: true         # 指标上打 route 名称标签

copy_strategy:
  enable: false
  copy_dispatch:
    # copy 触发交易的调度方式："parallel" 立即并发落地；"queued" 入队串行提交的流程
    mode: "queued"
    # 并发模式的在飞上限；表示最多允许多少条组装交易同时执行落地。
    # 通过信号量实现，Permit 释放后新任务才能提交；在 queued 模式下忽略。
    max_inflight: 32
    # 队列模式的缓冲容量；所有触发交易扇出的组装任务都会排进同一个队列。
    # 当排队任务数超过该值时，后续触发交易将被阻塞或丢弃（取决于实现策略）。
    queue_capacity: 3000
    # 指定毫秒数再处理下一笔，防止 gRPC 源头过快导致组装交易爆发。
    replay_interval_ms: 100
    # 队列模式下组装交易异步提交之间的最小间隔；0 表示不额外等待
    # 仅在队列模式生效；队列消费者异步提交一笔组装交易后，会等待
    queue_send_interval_ms: 100
    # 每笔触发交易扇出的组装交易数量；parallel 模式一次性并发提交，
    # queued 模式按 queue_send_interval_ms 依次异步提交，共计 fanout_count 笔。
    fanout_count: 10
  wallets:
    - address: "AAAAA4WQFj5MByDDxmraSAtumvWk8eNTAL5421SAdLRA"
      # 计算单元限制系数；影响落地交易时分配的计算单元数量。
      cu_limit_multiplier: 0.93
      source:
        # 来源类型 rpc 或者 grpc
        type: "grpc"
        rpc:
          # 拉取交易的间隔 分钟
          pull_interval_minutes: 10
          # 拉取交易的数量
          pull_count: 100
          # 节点列表
          pull_endpoints:
            - "https://rpc.shyft.to?api_key=FgU1AVt-7pIiUk2j"
        grpc:
          yellowstone_grpc_url: "http://185.26.10.237:10000"
          # yellowstone grpc token
          yellowstone_grpc_token: ""
          # 包含的 program id
          include_program_ids:
            - "JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4"
          # 排除的 program id
          exclude_program_ids: 
            - ""
        enable_landers:
          - "jito"

# 后跑策略
# Backrun 策略的工作原理如下：
# 1. 机器人将监控您在 enable_dexs 中定义的市场，以及您上面定义的所有中间铸币厂
# 2. 如果交易导致池子价格波动超过 min_price_impact_pct，机器人会尝试创建交易来回滚它
# 3. 机器人将使用您在 TRADE_CONFIGS 中定义的交易规模，根据您正在运行的交易，随机生成一个介于
#    MIN_TRADE_BP 和 MAX_TRADE_BP 之间的交易规模。或者，您也可以在此处定义一个 FIXED_SIZE 作为交易规模。
# 4. 机器人将引通过 jupiter-swap-api quote 另一笔规模，创建一个完整的套利交易 tx
# 5. 如果交易有利润，且利润高于 MIN_QUOTE_PROFIT，机器人就会将其发送出去
back_run_strategy:
  enable: false
  # 只允许交易这些 dex
  enable_dexs: ["Perps", "SolFi"]
  # 允许使用的 lander 类型
  enable_landers: []
  # 交易备注
  memo: ""
  # 触发我们整一个套利交易的 slot 和 tx 的 memo
  trigger_memo: ""

  base_mints:
    - # 触发交易金额
      trigger_amount: 100
      # SOL
      mint: "So11111111111111111111111111111111111111112"
      # 最小报价利润
      min_quote_profit: 100000
      # 最小模拟利润
      min_simulated_profit: 100000
      # 跳过报价利润检查，jup 报价可能非常不准确，您可以与模拟一起使用来获取实际利润
      skip_profit_check_for_quote: false
      # 最小交易规模，如果生成的交易规模小于这个，机器人会跳过交易
      min_trade_size: 500000000
      # 最大交易规模，如果生成的交易规模大于这个，机器人会限制在这个规模
      max_trade_size: 150000000000
      trade_configs:
        - # 机器人会随机选择一个交易规模，介于 min_trade_bp 和 max_trade_bp 之间
          # 您可以定义多个配置，机器人将为相同的交易创建不同的 tx
          # 可以使用 trade bp 或者 fixed_size
          min_trade_bp: 2000
          max_trade_bp: 2000
        - # 固定交易规模，机器人会使用这个规模
          fixed_size: 1000000000
          # 路由类型，目前只支持 2hop
          route_types:
            - "2hop"

    - # 触发交易金额
      trigger_amount: 100
      # USDC
      mint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
      # 最小报价利润
      min_quote_profit: 100000
      # 最小模拟利润
      min_simulated_profit: 100000
      # 跳过报价利润检查，jup 报价可能非常不准确，您可以与模拟一起使用来获取实际利润
      skip_profit_check_for_quote: false
      # 最小交易规模，如果生成的交易规模小于这个，机器人会跳过交易
      min_trade_size: 500000000
      # 最大交易规模，如果生成的交易规模大于这个，机器人会限制在这个规模
      max_trade_size: 150000000000
      trade_configs:
        - # 机器人会随机选择一个交易规模，介于 min_trade_bp 和 max_trade_bp 之间
          # 您可以定义多个配置，机器人将为相同的交易创建不同的 tx
          # 可以使用 trade bp 或者 fixed_size
          min_trade_bp: 2000
          max_trade_bp: 2000
        - # 固定交易规模，机器人会使用这个规模
          fixed_size: 1000000000
          # 路由类型，目前只支持 2hop
          route_types:
            - "2hop"
