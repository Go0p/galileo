global:
  # rpc url
  rpc_url: "http://xxxx"
  # yellowstone grpc url
  yellowstone_grpc_url: "http://xxxx"
  # yellowstone grpc token
  yellowstone_grpc_token: ""

  wallet:
    # 套利钱包的私钥
    private_key: ""
    # 钱包允许的最小余额, s 为 SOL，l 为 lamports
    min_sol_balance: "1s"

    warp_or_unwrap_sol:
      # 自动 wrap/unwrap sol 到 wsols
      wrap_and_unwrap_sol: true
      # 计算单元价格，单位为微 lamports, 0表示不给优先费
      compute_unit_price_micro_lamports: 0

  instruction:
    # 指令备注
    memo: ""

  # 日志级别
  logging:
    level: "info"
    json: true

# 当使用 JUPITER_URL=http://0.0.0.0:18080 或 JUPITER_URL=http://127.0.0.1:18080 运行机器人时，
# 机器人将首先根据 intermedium 中获取的 mint。然后启动 JupV6 API，并将 FILTER_MARKETS_WITH_MINTS 设置为从 intermedium 提取的 mints。
# mints 数量越多，您获得的机会就越多，因为来自不同代币对的潜在路径越多。然而，数值越高也意味着从 JupV6 API 获取报价的时间越长，
# 并且会占用更多计算机资源。
jupiter:
  # 如果 JUPITER_URL 设置为其他值，则以下格式中的任何参数均不适用。
  # 当您拥有 JupV6 API 提供程序或自行运行它时，可以使用此选项。
  jupiter_url: "http://0.0.0.0:18080"

  # 设置为 true 时，不会在本地启动 Jupiter API。当你想在同一台机器上运行多个机器人时，这很有用。
  disable_local_binary: false

  # 完整列表在 https://lite-api.jup.ag/swap/v1/program-id-to-label 。您可以在启动 jup api 时选择要包含哪个 Dex。
  # 请使用 Dex 的地址（而非名称），并以逗号分隔。
  included_dexes: []

  excluded_dexes: []

  # 用于读取数据的 RPC。使用默认 JUPITER_URL 值时，此 RPC 还将用于启动 JupV6 API。
  # 如果未设置，则将使用 global 中 rpc_url 的值。
  jupiter_rpc_url: ""

  # 用于从 JupV6 调用引用的 maxAccounts 参数。建议不要将其设置为高于 32。此数字越高，您可以找到的路由越多。
  # 但由于账户总数存在限制，因此此处的数字过高也会导致出现无效路由的可能性更高，因为账户数量过多，并且搜索时间也会更长。
  jup_max_accounts: 32

  # 当设置为 true 时，它​​将从本地文件 mainnet.json 加载市场缓存。当你运行 jup 时，
  # 如果启动速度很慢，甚至出现 error reading a body from connection 错误，
  # 这个选项会很有用。你可以使用 wget https://cache.jup.ag/markets?v=4 -O mainnet.json 更新本地文件。
  use_local_market_cache: false

  # 支持的值： europa 、 file 、 remote
  # 此处的默认行为（remote）将获取您指定的中间铸币厂的所有市场的快照，并且仅在重启时更新它们。
  # Europa 模式会将铸币厂列表中的新市场传输到 Jupiter，但这对某些 RPC 来说可能非常繁重。
  market_mode: "remote"

  # Jup uses thread for 3 things: webserver, update, router. You can config thread count for webserver and update, the rest of the cores will be used for router.
  # Router thread is handling the workload to find the best route for each quote request. This can be heavy especially when you have USE_DIRECT_ROUTE_ONLY false.
  # Make sure you leave some cores beside WEBSERVER_THREAD_COUNT and UPDATE_THREAD_COUNT for routing calculation.
  # jupiter的webserver线程数
  jupiter_webserver: 24
  # jup的更新线程数
  jupiter_update: 5
  # jupiter的总线程数
  total_thread_count: 64
  # 设置为 true 时，机器人将仅寻找两跳（A -> B -> A）交易。设置为 true 将缩短跳转报价时间，加快落地速度。设置为 false 将获得更多机会，但需要更多报价时间。
  use_direct_route_only: false
  # 仅当 use_direct_route_only 为 false 时，此设置才会生效。
  # 将中间代币限制为具有稳定流动性的顶级代币集合。这将有助于降低兑换时潜在的高滑点错误率，并将对定价的影响降至最低。
  # 当您将 use_direct_route_only 设置为 false 时，这可以帮助加快 jupiter 的报价时间。不过，正如它所说，它也会限制在您的路线中使用的额外 mint。
  restrict_intermediate_tokens: true

# 机器人会尝试找到盈利路线，具体方法是：获取给定交易规模的 base_mint 到 intermediate_mints 的报价，
# 然后再获取 intermediate_mints 到 base_mint 的另一个报价，
# 并将它们组合起来，形成一条潜在的盈利路线。基本上就是一条从 A -> B -> A 的路线。
# 当 use_direct_route_only 设置为 true 时，机器人将仅返回类似上述 A -> B -> A 形式的路线。
# 为了获得更多潜在机会，您可以将其设置为 false，这样可以返回类似 A -> B -> C -> A 形式的路线。
# 将其设置为 false 的缺点是会减慢获取报价的时间，最终导致交易发送速度变慢。
intermedium:
  load_mints_from_files: []
  load_mints_from_url: ""
  max_tokens_limit: 20
  mints:
    - "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
  disable_mints: []

bot:
  manager:
    # 是否禁止启动机器人
    disable_running: false
    # request timeout ms
    request_timeout_ms: 2000
    # 自动重启 jupiter binary 的时间间隔，单位为分钟，0表示不重启
    auto_restart_minutes: 30
    # 是否通过 geyser 获取 block hash, 否则通过 rpc 获取
    get_block_hash_by_grpc: true
    # 是否允许模拟
    enable_simulation: false

flashloan:
  # 是否启用 flash 贷款
  enable: false

# lander 相关配置已移至独立的 lander.yaml

# 垃圾邮件策略
spam:
  # 是否启用 spam
  enable: false
  enable_log: false
  skip_preflight: true
  max_retries: 0
  compute_unit_price_micro_lamports: 400000
  # 只允许交易这些 dex
  enable_dexs: []
  enable_landers:
    - "jito"
    - "staked"

# 盲发策略
blind:
  enable: false
  memo: ""
  # 只允许交易这些 dex
  enable_dexs: []
  enable_landers: []
  base_mints:
    - mint: ""
      trade_size_range:
        - 10
        - 100
      # 在范围内将生成多少种不同的交易规模
      trade_range_count: 3
      # 目前支持三个值： linear 、 random 、 exponential
      # exponential 将根据指数值生成交易规模。例如，对于 10 - 1000 的范围，计数为 5，它将生成如下交易规模：[10, 77, 315, 668, 1000]
      # linear 将根据线性值生成交易规模。例如，对于 10 - 1000 的范围，计数为 5，它将生成如下交易规模：[10, 200, 400, 600, 800, 1000]
      # 注意：随机报价比线性报价或固定交易规模报价稍慢。随机报价会依次发送两个报价，
      # 固定规模报价则会同时发送两个报价。
      trade_range_strategy: "linear"
      # 最小利润
      min_quote_profit: 5000
      # 交易延时
      # 单位为毫秒。默认值表示机器人将等待 1000 毫秒，然后针对相同代币交易规模的对再次尝试。减少此值将增加立即捕捉价格变化的机会，但会增加读取 RPC 负载。
      process_delay: 1000
      # 冷却时间
      # 如果找到一个机会并且发送了 tx，则至少等待这个时间（ms）才能发送另一个。
      sending_cooldown: 1000
      # 路由类型
      # 2hop ：这意味着只有像 A -> B -> A 这样的路由才会被考虑。如果您还将 use_direct_route_only 设置为 false，则 A->B 和 B->A 之间可能存在其他铸币厂。
      # 3hop ：这意味着只会考虑像 A -> B -> C -> A 这样的路线。您需要设置除了所有中间铸币厂之外，还希望在中间包含哪些额外的铸币厂。
      # 最常见的用例是使用 SOL 和 USDC 为路线报价，例如 SOL -> USDC -> X -> SOL。3hop 会产生与将 use_direct_route_only 设置为 false 类似的结果，但报价时间要快得多
      # 使用 3hop 时还需要定义 three_hop_mints
      route_types:
        - "2hop"
        - "3hop"
      # 三跳交易中，中间的铸币厂
      three_hop_mints:
        - "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"

# 后跑策略
# Backrun 策略的工作原理如下：
# 1. 机器人将监控您在 enable_dexs 中定义的市场，以及您上面定义的所有中间铸币厂
# 2. 如果交易导致池子价格波动超过 min_price_impact_pct，机器人会尝试创建交易来回滚它
# 3. 机器人将使用您在 TRADE_CONFIGS 中定义的交易规模，根据您正在运行的交易，随机生成一个介于
#    MIN_TRADE_BP 和 MAX_TRADE_BP 之间的交易规模。或者，您也可以在此处定义一个 FIXED_SIZE 作为交易规模。
# 4. 机器人将引通过 jupiter-swap-api quote 另一笔规模，创建一个完整的套利交易 tx
# 5. 如果交易有利润，且利润高于 MIN_QUOTE_PROFIT，机器人就会将其发送出去
back_run:
  enable: false
  # 只允许交易这些 dex
  enable_dexs: []
  # 允许使用的 lander 类型
  enable_landers: []
  # 交易备注
  memo: ""
  # 触发我们整一个套利交易的 slot 和 tx 的 memo
  trigger_memo: ""

  base_mints:
    - # 触发交易金额
      trigger_amount: 100
      # SOL
      mint: "So11111111111111111111111111111111111111112"
      # 最小报价利润
      min_quote_profit: 100000
      # 最小模拟利润
      min_simulated_profit: 100000
      # 跳过报价利润检查，jup 报价可能非常不准确，您可以与模拟一起使用来获取实际利润
      skip_profit_check_for_quote: false
      # 最小交易规模，如果生成的交易规模小于这个，机器人会跳过交易
      min_trade_size: 500000000
      # 最大交易规模，如果生成的交易规模大于这个，机器人会限制在这个规模
      max_trade_size: 150000000000
      trade_configs:
        - # 机器人会随机选择一个交易规模，介于 min_trade_bp 和 max_trade_bp 之间
          # 您可以定义多个配置，机器人将为相同的交易创建不同的 tx
          # 可以使用 trade bp 或者 fixed_size
          min_trade_bp: 2000
          max_trade_bp: 2000
        - # 固定交易规模，机器人会使用这个规模
          fixed_size: 1000000000
          # 路由类型，目前只支持 2hop
          route_types:
            - "2hop"

    - # 触发交易金额
      trigger_amount: 100
      # USDC
      mint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
      # 最小报价利润
      min_quote_profit: 100000
      # 最小模拟利润
      min_simulated_profit: 100000
      # 跳过报价利润检查，jup 报价可能非常不准确，您可以与模拟一起使用来获取实际利润
      skip_profit_check_for_quote: false
      # 最小交易规模，如果生成的交易规模小于这个，机器人会跳过交易
      min_trade_size: 500000000
      # 最大交易规模，如果生成的交易规模大于这个，机器人会限制在这个规模
      max_trade_size: 150000000000
      trade_configs:
        - # 机器人会随机选择一个交易规模，介于 min_trade_bp 和 max_trade_bp 之间
          # 您可以定义多个配置，机器人将为相同的交易创建不同的 tx
          # 可以使用 trade bp 或者 fixed_size
          min_trade_bp: 2000
          max_trade_bp: 2000
        - # 固定交易规模，机器人会使用这个规模
          fixed_size: 1000000000
          # 路由类型，目前只支持 2hop
          route_types:
            - "2hop"
