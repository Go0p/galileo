global:
  # rpc url
  # rpc_url: "https://rpc.shyft.to?api_key=FgU1AVt-7pIiUk2j"
  # rpc_url: "https://mainnet.solana.validationcloud.io/v1/4YlOowpz6fTe6Jl31oWxYGSusOS12UzTxXkpdoC1I5A"
  rpc_url: "https://mainnet.helius-rpc.com/?api-key=39602420-7609-49be-905e-92421ddcb342"
  # rpc_url: "https://solana-rpc.publicnode.com"
  # rpc_url: "http://127.0.0.1:8899"
  # yellowstone grpc url
  # proxy: "http://192.168.124.4:2080"
  yellowstone_grpc_url: ""
  # yellowstone grpc token
  yellowstone_grpc_token: ""

  wallet:
    # 套利钱包的私钥 loss
    private_key: ""
    # copy
    # private_key: "5nZhEDFQXG9GDURkRi7RmtzeZ7WywjW7MMmu7BdvHSG7WpmvxxfqomFkbHhEthMajrv31zRKxei2GdNawnnx2RF6"
    # 自动 unwrap WSOL 到 SOL
    auto_unwrap:
      # 开启后当钱包 SOL 余额低于阈值时，自动把 WSOL 解包为 SOL
      enable: false
      # 每次自动解包的金额
      unwrap_amount_lamports: 1000000000
      # 钱包允许的最小 SOL 余额阈值（单位：lamports）
      min_sol_balance_lamports: 1000000000
      # 执行解包交易时使用的 CU price（单位：微 lamports）
      compute_unit_price_micro_lamports: 0

  instruction:
    # 指令备注
    memo: ""

  # 日志级别
  logging:
    level: "info"
    json: false
    # 日志输出的时区偏移（单位：小时）。示例：8 代表 UTC+8。
    timezone_offset_hours: 8

engine:
  jupiter:
    enable: true
    api_proxy: "http://192.168.124.4:9999"
    args_included_dexes: [
      # TesseraV
      "TessVdML9pBGgG9yGks7o4HewRaXVAMuoVj4x83GLQH",
      # SolFiV2
      "SV2EYYJyRz2YhfXwXnhNAevDEui5Q6yrfyo13WtupPF",
      # HumidiFi
      "9H6tua7jkLhdm3w8BvgpTn5LZNU7g4ZynDmCiNN3q6Rp",
      # Aquifer
      "AQU1FRd7papthgdrwPTTq5JacJh8YtwEXaBfKU3bTz45"
    ]
    quote_config:
      # 设置为 true 时，机器人将仅寻找两跳（A -> B -> A）交易。设置为 true 将缩短跳转报价时间，加快落地速度。设置为 false 将获得更多机会，但需要更多报价时间。
      only_direct_routes: false
      # 仅当 use_direct_route_only 为 false 时，此设置才会生效。
      # 将中间代币限制为具有稳定流动性的顶级代币集合。这将有助于降低兑换时潜在的高滑点错误率，并将对定价的影响降至最低。
      # 当您将 use_direct_route_only 设置为 false 时，这可以帮助加快 jupiter 的报价时间。不过，正如它所说，它也会限制在您的路线中使用的额外 mint。
      restrict_intermediate_tokens: true
    swap_config:
      # 跳过用户账户相关 RPC 调用，以减少重复拉取。
      # 设置为 false 时，不会有 setupInstructions 等创建 ATA 的指令
      # 设置为 true 时，会有 setupInstructions 等创建 ATA 的指令
      skip_user_accounts_rpc_calls: false
      # 启用后，它将进行交换模拟以获取使用的计算单元并将其设置在 ComputeBudget 的计算单元限制中
      # 这会导致一个额外的 RPC 调用来模拟这个交易
      # 我们建议启用此功能以正确估计计算单元并减少所需的优先费用或有更高的机会被纳入区块
      dynamic_compute_unit_limit: true
      wrap_and_unwrap_sol: false



# 机器人会尝试找到盈利路线，具体方法是：获取给定交易规模的 base_mint 到 intermediate_mints 的报价，
# 然后再获取 intermediate_mints 到 base_mint 的另一个报价，
# 并将它们组合起来，形成一条潜在的盈利路线。基本上就是一条从 A -> B -> A 的路线。
# 当 use_direct_route_only 设置为 true 时，机器人将仅返回类似上述 A -> B -> A 形式的路线。
# 为了获得更多潜在机会，您可以将其设置为 false，这样可以返回类似 A -> B -> C -> A 形式的路线。
# 将其设置为 false 的缺点是会减慢获取报价的时间，最终导致交易发送速度变慢。
intermedium:
  load_mints_from_files: []
  load_mints_from_url: ""
  max_tokens_limit: 20
  mints:
    - "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
    - "So11111111111111111111111111111111111111112"
  disable_mints: []

bot:
  # 是否测试模式
  dry_run: false
  cpu_affinity:
    # 开启后，bot 会将 Tokio runtime 线程绑定到指定 CPU 核，避免与验证节点争抢
    enable: false
    # 按顺序列出可用的物理/超线程 ID，例如 [3,4,5,6]；留空表示使用全部可用核心
    worker_cores: []
    # 可选：限制 Tokio 阻塞线程池的最大线程数；置空表示使用默认值
    max_blocking_threads: null
    # 严格模式：当核心列表无效时直接报错退出，而不是回退到默认调度
    strict: false
  # 是否启用 prometheus
  prometheus:
    enable: true
    listen: "0.0.0.0:9898"
  # 设置为 true 时，不会在本地启动 Jupiter API。当你想在同一台机器上运行多个机器人时，这很有用。
  disable_local_binary: false
  # 是否禁止启动机器人
  disable_running: false
  # 超时时间：报价 / 指令 / 落地（单位：毫秒）
  quote_ms: 2000
  swap_ms: 10000
  landing_ms: 5000
  # 自动重启 jupiter binary 的时间间隔，单位为分钟，0表示不重启
  auto_restart_minutes: 30
  # 是否通过 geyser 获取 block hash, 否则通过 rpc 获取
  get_block_hash_by_grpc: true
  # 是否允许模拟
  enable_simulation: false
  # 是否在本地终端打印 Jupiter 二进制输出（默认开启，可保持彩色日志）。
  show_jupiter_logs: true

flashloan:
  marginfi:
    # 是否启用 flash 贷款
    enable: true
    # 优先使用钱包余额；若交易规模在余额内，则跳过闪电贷
    prefer_wallet_balance: true
    # marginfi_account: "AfXar5qXsgS5H2NYXcmcfZxrsxUFah7uUrpFcgxo91ZJ"
    marginfi_accounts:
      - wsol: "DkLdmQPbFn3U6HDqspGrTeN8wcAo17GxHyczo5YV7KpW"
      - usdc: ""

# lander 相关配置已移至独立的 lander.yaml

# 盲发策略
blind_strategy:
  enable: true
  pure_mode: true
  memo: ""
  # 只允许交易这些 dex
  enable_dexs: [
      "HumidiFi",
      "SolFiV2",
      "TesseraV",
      "ZeroFi",
      "Perps",
      "GoonFi"
  ]
  enable_landers: [
        # "jito"
    ]
  base_mints:
    - mint: "So11111111111111111111111111111111111111112"
      trade_size_range:
        - 1_000_000_000 # 10 SOL
        - 5_000_000_000 # 100 SOL
      # 在范围内将生成多少种不同的交易规模
      trade_range_count: 3
      # 目前支持三个值： linear 、 random 、 exponential
      # exponential 将根据指数值生成交易规模。例如，对于 10 - 1000 的范围，计数为 5，它将生成如下交易规模：[10, 77, 315, 668, 1000]
      # linear 将根据线性值生成交易规模。例如，对于 10 - 1000 的范围，计数为 5，它将生成如下交易规模：[10, 200, 400, 600, 800, 1000]
      # 注意：随机报价比线性报价或固定交易规模报价稍慢。随机报价会依次发送两个报价，
      # 固定规模报价则会同时发送两个报价。
      trade_range_strategy: "linear"
      # 最小利润
      min_quote_profit: 0
      # 交易延时
      # 单位为毫秒。默认值表示机器人将等待 1000 毫秒，然后针对相同代币交易规模的对再次尝试。减少此值将增加立即捕捉价格变化的机会，但会增加读取 RPC 负载。
      process_delay: 1000
      # 冷却时间
      # 如果找到一个机会并且发送了 tx，则至少等待这个时间（ms）才能发送另一个。
      sending_cooldown: 1000
      # 路由类型
      # 2hop ：这意味着只有像 A -> B -> A 这样的路由才会被考虑。如果您还将 use_direct_route_only 设置为 false，则 A->B 和 B->A 之间可能存在其他铸币厂。
      # 3hop ：这意味着只会考虑像 A -> B -> C -> A 这样的路线。您需要设置除了所有中间铸币厂之外，还希望在中间包含哪些额外的铸币厂。
      # 最常见的用例是使用 SOL 和 USDC 为路线报价，例如 SOL -> USDC -> X -> SOL。3hop 会产生与将 use_direct_route_only 设置为 false 类似的结果，但报价时间要快得多
      # 使用 3hop 时还需要定义 three_hop_mints
      route_types:
        - "2hop"
        - "3hop"
      # 三跳交易中，中间的铸币厂
      three_hop_mints:
        - "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
  pure_routes:
    - name: "solfi_cycle"
      # https://solscan.io/tx/TBAnSKbNuNdu2kCPMcLhM8BYh8awZZ5Gt8DTw4k7cFV9DP9YUY86fxc7w9mQ3R5T1L1yeXTh2a4vTkf3izizYFa
      legs:
        # HumidiFi
        # - market: "DB3sUCP2H4icbeKmK6yb6nUxU5ogbcRHtGuq7W2RoRwW"
        # TesseraV
        # - market: "FLckHLGMJy5gEoXWwcE68Nprde1D4araK4TGLw4pQq2n"
        # ZeroFi
        # - market: "DRciepTenS2bwfA9YJkZraZrFzcUpmVebR4aZgo2zj1k"
        # SolFi V2
        # - market: "65ZHSArs5XxPseKQbB1B4r16vDxMWnCxHMzogDAqiDUc"
        - market: "DB3sUCP2H4icbeKmK6yb6nUxU5ogbcRHtGuq7W2RoRwW" # Humidifi WSOL-USDC
        - market: "HktfL7iwGKT5QHjywQkcDnZXScoh811k7akrMZJkCcEF"  # whirlpool SOL-WETH
        - market: "BqkNuLTbUZLifWuUtfF5CkyRegTQhYYgUnNeUaxoWC8S"  # ZeroFi WETH-USDC
      lookup_tables:
        - 3RRynG7FN6FkVaAyZPHwZSAGYUWzxb1EmtM5CfrShhsw
        - "AW3raiF9cvqu8d5JgCXmCi8kh16Aba86gWVi9pbNYNNc"
        - "5CMHLs9MphE5Nhox4hrqF72e8utWmu8ZH8UtVegT6WL2"
        - "FqeeFKhvn4d19iJA7G4qU9tcfjHNUkEo2rKsht5Btztm"


# 后跑策略
# Backrun 策略的工作原理如下：
# 1. 机器人将监控您在 enable_dexs 中定义的市场，以及您上面定义的所有中间铸币厂
# 2. 如果交易导致池子价格波动超过 min_price_impact_pct，机器人会尝试创建交易来回滚它
# 3. 机器人将使用您在 TRADE_CONFIGS 中定义的交易规模，根据您正在运行的交易，随机生成一个介于
#    MIN_TRADE_BP 和 MAX_TRADE_BP 之间的交易规模。或者，您也可以在此处定义一个 FIXED_SIZE 作为交易规模。
# 4. 机器人将引通过 jupiter-swap-api quote 另一笔规模，创建一个完整的套利交易 tx
# 5. 如果交易有利润，且利润高于 MIN_QUOTE_PROFIT，机器人就会将其发送出去
back_run_strategy:
  enable: false
  # 只允许交易这些 dex
  enable_dexs: [
      "Perps",
      "SolFi"
  ]
  # 允许使用的 lander 类型
  enable_landers: []
  # 交易备注
  memo: ""
  # 触发我们整一个套利交易的 slot 和 tx 的 memo
  trigger_memo: ""

  base_mints:
    - # 触发交易金额
      trigger_amount: 100
      # SOL
      mint: "So11111111111111111111111111111111111111112"
      # 最小报价利润
      min_quote_profit: 100000
      # 最小模拟利润
      min_simulated_profit: 100000
      # 跳过报价利润检查，jup 报价可能非常不准确，您可以与模拟一起使用来获取实际利润
      skip_profit_check_for_quote: false
      # 最小交易规模，如果生成的交易规模小于这个，机器人会跳过交易
      min_trade_size: 500000000
      # 最大交易规模，如果生成的交易规模大于这个，机器人会限制在这个规模
      max_trade_size: 150000000000
      trade_configs:
        - # 机器人会随机选择一个交易规模，介于 min_trade_bp 和 max_trade_bp 之间
          # 您可以定义多个配置，机器人将为相同的交易创建不同的 tx
          # 可以使用 trade bp 或者 fixed_size
          min_trade_bp: 2000
          max_trade_bp: 2000
        - # 固定交易规模，机器人会使用这个规模
          fixed_size: 1000000000
          # 路由类型，目前只支持 2hop
          route_types:
            - "2hop"

    - # 触发交易金额
      trigger_amount: 100
      # USDC
      mint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
      # 最小报价利润
      min_quote_profit: 100000
      # 最小模拟利润
      min_simulated_profit: 100000
      # 跳过报价利润检查，jup 报价可能非常不准确，您可以与模拟一起使用来获取实际利润
      skip_profit_check_for_quote: false
      # 最小交易规模，如果生成的交易规模小于这个，机器人会跳过交易
      min_trade_size: 500000000
      # 最大交易规模，如果生成的交易规模大于这个，机器人会限制在这个规模
      max_trade_size: 150000000000
      trade_configs:
        - # 机器人会随机选择一个交易规模，介于 min_trade_bp 和 max_trade_bp 之间
          # 您可以定义多个配置，机器人将为相同的交易创建不同的 tx
          # 可以使用 trade bp 或者 fixed_size
          min_trade_bp: 2000
          max_trade_bp: 2000
        - # 固定交易规模，机器人会使用这个规模
          fixed_size: 1000000000
          # 路由类型，目前只支持 2hop
          route_types:
            - "2hop"
